name: Log Android Issue Form Fields

on:
  issues:
    types: [opened]

permissions:
  issues: read

jobs:
  log-fields:
    runs-on: ubuntu-latest
    steps:
      - name: Log all issue form fields (by ID)
        shell: bash
        run: |
          node <<'NODE'
          const fs = require("fs");

          // GitHub stores the webhook/event payload on disk for the runner
          const event = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH, "utf8"));

          const issue = event.issue || {};
          const body = (issue.body || "").replace(/\r\n/g, "\n");

          // Map your FIELD IDs to the exact label text from the issue template.
          // These become "### <label>" headings in the generated issue body. If you change labels in android_sdk_bug.yml, update these strings.
          const fields = [
            { id: "severity", label: "Severity (customer-facing)" },
            { id: "sdk-version", label: "SDK Version" },
            { id: "sdk-version-other", label: 'If "Other", specify the exact SDK version' },
            { id: "android-version", label: "Android OS / API Level" },
            { id: "device", label: "Device model(s)" },
            { id: "gradle-version", label: "Gradle Version" },
            { id: "kotlin-version", label: "Kotlin Version" },
            { id: "steps-to-reproduce", label: "Steps to reproduce" },
            { id: "expected-behavior", label: "Expected behavior" },
            { id: "actual-behavior", label: "Actual behavior" },
            { id: "logs", label: "Logs / stacktrace (redacted)" },
            { id: "additional-context", label: "Additional context" },
            { id: "confirmations", label: "Confirmations" },
          ];

          // Parse the issue body into sections based on "### <heading>" markers.
          // Issue forms typically use H3 headings as separators in the generated markdown.
          function parseSections(markdown) {
            const lines = markdown.split("\n");
            const sections = new Map();
            let current = null;

            for (const line of lines) {
              const m = line.match(/^###\s+(.*)\s*$/);
              if (m) {
                current = m[1].trim();
                if (!sections.has(current)) sections.set(current, []);
                continue;
              }
              if (current) sections.get(current).push(line);
            }

            // Normalize each section to trimmed text
            const normalized = {};
            for (const [heading, contentLines] of sections.entries()) {
              const text = contentLines.join("\n").trim();
              normalized[heading] = text;
            }
            return normalized;
          }

          // Treat these as "not entered"
          function isEmptyValue(v) {
            if (v == null) return true;
            const t = String(v).trim();
            return t.length === 0 || t.toLowerCase() === "_no response_" || t.toLowerCase() === "n/a";
          }

          // Special parsing for checkboxes field
          function parseCheckboxes(block) {
            const checked = [];
            const unchecked = [];
            const lines = block.split("\n").map(l => l.trim());
            for (const l of lines) {
              const m = l.match(/^- \[(x| )\]\s+(.*)$/i);
              if (!m) continue;
              const isChecked = m[1].toLowerCase() === "x";
              const text = (m[2] || "").trim();
              if (!text) continue;
              (isChecked ? checked : unchecked).push(text);
            }
            return { checked, unchecked };
          }

          const sections = parseSections(body);

          const output = {};
          for (const f of fields) {
            const raw = sections[f.label];

            if (raw === undefined || isEmptyValue(raw)) {
              output[f.id] = `Field ${f.id} wasn't entered.`;
              continue;
            }

            if (f.id === "confirmations") {
              const parsed = parseCheckboxes(raw);
              // Always log the structure (even if user only checked 1)
              output[f.id] = parsed;
            } else {
              output[f.id] = raw;
            }
          }

          // Log only the field outputs (IDs -> values)
          console.log(JSON.stringify(output, null, 2));
          NODE
